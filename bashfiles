#!/bin/bash
# bashfiles - Manage CloudFiles via the command-line

BF_VERSION=0.1
BF_PROG=`basename $0`
BF_CONFIG=~/.$BF_PROG
BF_COMPLETION_DIR=~/.$BF_PROG-completion

DEFAULT_CF_AUTH_URL_US=https://auth.api.rackspacecloud.com/v1.0
DEFAULT_CF_AUTH_URL_UK=https://lon.auth.api.rackspacecloud.com/v1.0

CF_SEGMENT_SIZE=5368709120
CF_INITIALIZED=0
DD_BLOCK_SIZE=1024

OPT_CONTENT_TYPE=
OPT_FORCE=0
OPT_OUTPUT=
OPT_QUIET=0
OPT_SERVICENET=0

CONST_ZERO_MD5=d41d8cd98f00b204e9800998ecf8427e


#############################################################################
#                                                                           #
#                               Bashfiles                                   #
#                                                                           #
#############################################################################


function bf_help() {
    cat <<EOF
SYNOPSIS

    $BF_PROG [options] [commands] [container] [object-names]

DESCRIPTION

    $BF_PROG is a utility for working with Rackspace CloudFiles via the
    command-line. $BF_PROG has minimal dependencies, requiring only bash, curl,
    and a few other POSIX utilities.

    You can pass settings to $BF_PROG via environment variables or by defining a
    configuration file located at `~/.bashfiles`.

    $BF_PROG supports bash-completion against commands, container and
    object-names, and can be enabled with the BF_SMART_COMPLETION=1 setting.

OPTIONS

    -h      Print help
    -f      Force
    -o      Output filename ('-' to output to stdout)
    -q      Quiet mode (suppress progress meter)
    -s      Use Rackspace's ServiceNET network
    -t      Specify Content-Type for an upload (autodetect by default)
    -v      Print version

COMMANDS

    cp      Server-side object copy
    get     Download file (-f overwrites existing file, if present)
    ls      List all containers or contents of a specific container
    mkdir   Create a container
    mv      Server-side object move
    put     Upload file
    rmdir   Remove a container (-f to clear it first)
    stat    Account, container, or object information

SETTINGS

    CF_USER         CloudFiles username
    CF_API_KEY      CloudFiles API Key
    CF_AUTH_URL     CloudFiles authentication URL
    CF_SERVICENET   Use Rackspace's ServiceNET network
    BF_SMART_COMPLETION
                    Whether to enable bash completion against object and
                    container-names

FILES

    ~/.bashfiles
    ~/.bashfiles-completion

AUTHORS

    Rick Harris
    Mike Barton
    Chmouel Boudjnah
    Jay Payne

BUGS

    Report to https://github.com/rconradharris/cloudfiles2.sh
EOF
    exit 0
}


function bf_log() {
    if [[ $OPT_QUIET -eq 0 ]]; then
        echo "$@" >&2
    fi
}


function bf_warn() {
    echo "warning: $@" >&2
}


function bf_error() {
    echo "error: $@" >&2
}


function bf_die() {
    echo "$@" >&2
    exit 1
}


function bf_version() {
    echo $BF_VERSION
    exit 0
}


function bf_usage() {
    bf_die "usage: $BF_PROG [-fhqstv] $@"
}


function bf_general_usage() {
    bf_usage '<cp|get|ls|mkdir|mv|put|rm|rmdir|stat> [container] [object-name]'
}


function bf_load_config() {
    if [[ -r $BF_CONFIG ]]; then
        source $BF_CONFIG
    fi
}


function bf_ask() {
    local question=$1

    read -p "$question"
    echo $REPLY
}


function bf_ask_required() {
    local var=$1
    local question=$2
    local reply=`bf_ask "$question"`
    if [[ -z $reply ]]; then
        bf_die 'Aborted'
    fi
    eval $var="'$reply'"
}


function bf_ask_with_default() {
    local default=$1
    local question=$2

    local reply=`bf_ask "$question"`

    if [[ -z $reply ]]; then
        reply=$default
    fi

    echo "$reply"
}


function bf_save_config() {
    if [[ -e $BF_CONFIG ]]; then
        bf_warn "Cannot save credentials, file $BF_CONFIG already exists"
        return
    fi
    cat > $BF_CONFIG <<EOF
CF_USER=$CF_USER
CF_API_KEY=$CF_API_KEY
CF_AUTH_URL=$CF_AUTH_URL
BF_SMART_COMPLETION=$BF_SMART_COMPLETION
CF_SERVICENET=$CF_SERVICENET
EOF
}


function bf_retrieve_credentials() {
    local creds_updated=0

    # 1. Check config file
    # 2. Check environment
    # 3. Ask user
    # 4. Optional: Save credentials to config file
    bf_load_config

    if [[ -z $CF_USER ]]; then
        bf_ask_required 'CF_USER' 'CloudFiles Username: '
        creds_updated=1
    fi

    if [[ -z $CF_API_KEY ]]; then
        bf_ask_required 'CF_API_KEY' 'CloudFiles API Key: '
        creds_updated=1
    fi

    if [[ -z $CF_AUTH_URL ]]; then
        local auth_url=$(bf_ask_with_default us \
                         'Location or Auth URL: [<url>/uk/US]: ')

        if [[ $auth_url == 'uk' || $auth_url == 'UK' ]]; then
            CF_AUTH_URL=$DEFAULT_CF_AUTH_URL_UK
        elif [[ $auth_url == 'us' || $auth_url == 'US' ]]; then
            CF_AUTH_URL=$DEFAULT_CF_AUTH_URL_US
        else
            CF_AUTH_URL=$auth_url
        fi
    fi

    if [[ -z $CF_SERVICENET ]]; then
        local snet=`bf_ask_with_default n 'Use ServiceNET [y/N]? '`

        if [[ $snet = 'y' || $snet = 'Y' ]]; then
            CF_SERVICENET=1
        else
            CF_SERVICENET=0
        fi
    fi

    if [[ $creds_updated -eq 1 ]]; then
        # Only ask about smart completion if we were already asking for USER
        # or API_KEY
        if [[ -z $BF_SMART_COMPLETION ]]; then
            local smart_completion=$(bf_ask_with_default y \
                         'Enable container and object name completion [Y/n]? ')

            if [[ $smart_completion = 'y' || $smart_completion = 'Y' ]]; then
                BF_SMART_COMPLETION=1
            else
                BF_SMART_COMPLETION=0
            fi
        fi

        local save_creds=`bf_ask_with_default N 'Save settings [y/N]? '`

        if [[ $save_creds = 'y' || $save_creds = 'Y' ]]; then
            bf_save_config
        fi
    fi
}


function bf_md5() {
    if [[ -e /sbin/md5 ]]; then
        # OSX
        echo `md5 -q $1`
    else
        # Linux
        echo `md5sum -q $1`
    fi
}


function bf_urlencode() {
    # http://gimi.name/snippets/urlencode-and-urldecode-for-bash-scripting-using-sed/
    echo "$1" | sed -e 's/%/%25/g;s/ /%20/g;s/ /%09/g;s/!/%21/g;s/"/%22/g;' \
                    -e 's/#/%23/g;s/\$/%24/g;s/\&/%26/g;s/'\''/%27/g;'\
                    -e 's/(/%28/g;s/)/%29/g;s/\*/%2a/g;s/+/%2b/g;'\
                    -e 's/,/%2c/g; s/-/%2d/g; s/\./%2e/g; s/:/%3a/g;'\
                    -e 's/;/%3b/g; s//%3e/g; s/?/%3f/g; s/@/%40/g;'\
                    -e 's/\[/%5b/g; s/\\/%5c/g; s/\]/%5d/g; s/\^/%5e/g;'\
                    -e 's/_/%5f/g; s/`/%60/g; s/{/%7b/g; s/|/%7c/g;'\
                    -e 's/}/%7d/g; s/~/%7e/g; s/      /%09/g;'
}


function bf_mktemp() {
    echo `mktemp -t $BF_PROG`
}


function bf_size() {
    local filename=$1

    if stat -c 2>&1 | grep -q illegal; then
        # Mac OS X
        echo `stat -f%z ${filename}`
    else
        # Linux
        echo `stat -c%s ${filename}`
    fi
}


function bf_compute_num_blocks() {
    local total_size=$1
    local block_size=$2

    let nblocks=$total_size/$block_size
    let reminader=$total_size%$block_size

    if [[ $remainder -gt 0 ]]; then
        let nblocks++
    fi

    echo $nblocks
}


function bf_autodetect_filetype() {
    local filename=$1
    echo `file --brief --mime $filename`
}


#############################################################################
#                                                                           #
#                               Commands                                    #
#                                                                           #
#############################################################################


function cmd_cp() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    if [[ -z $src_container || -z $src_obj_name
                            || -z $dst_container \
                            || -z $dst_obj_name ]]; then
        bf_usage 'cp <src-container> <src-object-name>' \
                 ' <dst-container> <dst-object-name>'
    fi

    cf_cp $src_container $src_obj_name $dst_container $dst_obj_name
}


function cmd_get() {
    local container=$1
    shift
    local obj_names=$@

    if [[ -z $container || -z $obj_names ]]; then
        bf_usage 'get <container> <object-names>'
    fi

    cf_get $container $obj_names
}


function cmd_ls() {
    local container=$1
    local tmp_file=`bf_mktemp`

    cf_ls "$container" $tmp_file

    cat $tmp_file

    if [[ $BF_SMART_COMPLETION -eq 1 ]]; then
        if [[ -z $container ]]; then
            mv $tmp_file $BF_COMPLETION_DIR/container-names
        else
            mv $tmp_file $BF_COMPLETION_DIR/$container-object-names
        fi
    else
        rm $tmp_file
    fi
}


function cmd_mkdir() {
    local containers=$@

    if [[ -z $containers ]]; then
        bf_usage 'mkdir <containers>'
    fi

    cf_mkdir $containers
}


function cmd_mv() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    if [[ -z $src_container || -z $src_obj_name
                            || -z $dst_container \
                            || -z $dst_obj_name ]]; then
        bf_usage 'mv <src-container> <src-object-name>' \
                 ' <dst-container> <dst-object-name>'
    fi

    cf_mv $src_container $src_obj_name $dst_container $dst_obj_name
}


function cmd_put() {
    local container=$1
    shift
    local filenames=$@

    if [[ -z $container || -z $filenames ]]; then
        bf_usage 'put <container> <filenames>'
    fi

    cf_put $container $filenames
}


function cmd_rm() {
    local container=$1
    shift
    local obj_names=$@

    if [[ -z $container || -z $obj_names ]]; then
        bf_usage 'rm <container> <object-names>'
    fi

    cf_rm $container $obj_names
}


#############################################################################
#                                                                           #
#                               CloudFiles                                  #
#                                                                           #
#############################################################################


function bf_handle_snet() {
    if [[ $OPT_SERVICENET -eq 1 || $CF_SERVICENET -eq 1 ]]; then
        CF_STORAGE_URL=${CF_STORAGE_URL/https:\/\//https://snet-}
        CF_STORAGE_URL=${CF_STORAGE_URL/http:\/\//http://snet-}
    fi
}


function bf_auth() {
    if [[ -z $CF_AUTH_URL ]]; then
        CF_AUTH_URL=$DEFAULT_CF_AUTH_URL_US
    fi

    local auth_resp=$(
        curl --silent --fail --dump-header - \
             --header "X-Auth-Key: $CF_API_KEY" \
             --header "X-Auth-User: $CF_USER" \
             ${CF_AUTH_URL})

    CF_AUTH_TOKEN=$(echo "$auth_resp" | grep ^X-Auth-Token \
                                      | sed 's/.*: //' \
                                      | tr -d "\r\n")

    CF_STORAGE_URL=$(echo "$auth_resp" | grep ^X-Storage-Url \
                                       | sed 's/.*: //' \
                                       | tr -d "\r\n")

    if [[ -z $CF_AUTH_TOKEN || -z $CF_STORAGE_URL ]]; then
        echo "Unable to authenticate, set credentials in $BF_CONFIG or" \
             " CF_USER and CF_API_KEY environment variables"
        exit 1
    fi

    bf_handle_snet
}


function bf_check_code() {
    local code=$1

    if [[ $code -lt 200 || $code -gt 299 ]]; then
        bf_die "Invalid response code: $code"
    fi
}


function bf_curl() {
    local url=`bf_urlencode $1`
    shift

    bf_init
    local code=$(curl --fail --write-out '%{http_code}' \
                      --header "X-Auth-Token: $CF_AUTH_TOKEN" \
                      "$@" "$CF_STORAGE_URL/$url")
    bf_check_code $code
}


function cf_cp() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    bf_curl $src_container/$src_obj_name --silent --request COPY \
            --header "Destination: /$dst_container/$dst_obj_name"
}


function cf_ls() {
    local container=$1
    local tmp_file=$2

    bf_curl "$container" --silent --output $tmp_file
}


function cf_get() {
    local container=$1
    shift
    local obj_names=$@

    if [[ $OPT_QUIET -eq 1 ]]; then
        local opt_silent=--silent
    else
        local opt_silent=
    fi

    for obj_name in $obj_names; do
        if [[ -n $OPT_OUTPUT ]]; then
            local filename=$OPT_OUTPUT
        else
            local filename=`basename $obj_name`
        fi

        if [[ $filename == - ]]; then
            # FIXME: unify with bf_curl
            bf_init
            obj_name=`bf_urlencode $obj_name`
            curl --fail --silent \
                 --header "X-Auth-Token: $CF_AUTH_TOKEN" \
                 $CF_STORAGE_URL/$container/$obj_name
            continue
        elif [[ -e $filename && $OPT_FORCE -ne 1 ]]; then
            bf_die "File '$filename' already exists"
        fi

        local output=.$filename.download
        local tmp_headers=`bf_mktemp`

        bf_curl $container/$obj_name $opt_silent --dump-header $tmp_headers \
                --output $output

        local etag=$(cat $tmp_headers | grep --ignore-case ^Etag \
                                      | sed 's/.*: //' \
                                      | tr -d "\r\n" \
                                      | tr -d '"')

        if [[ -z `grep --ignore-case X-Object-Manifest $tmp_headers` ]]; then
            local dlo=0
        else
            # NOTE: Dynamic Large Objects won't have an ETag that matches
            local dlo=1
        fi

        rm $tmp_headers

        if [[ $output == - ]]; then
            true
        elif [[ $etag == $CONST_ZERO_MD5 ]]; then
            # NOTE: If it's a 0-byte file, curl will not create the output
            # file, so we have to do that ourselves
            touch $filename
            bf_warn "Zero-byte file created"
        elif [[ $dlo -eq 1 || $etag == `bf_md5 $output` ]]; then
            mv $output $filename
        else
            rm $output
            bf_die "ERROR: Failed checksum validation."
        fi
    done
}


function cf_mkdir() {
    local containers=$@

    for container in $containers; do
        bf_curl $container --silent --output /dev/null --request PUT \
                --upload-file /dev/null
    done
}


function cf_mv() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    cf_cp $src_container $src_obj_name $dst_container $dst_obj_name
    cf_rm $src_container $src_obj_name
}


function cf_put_small_object() {
    local container=$1
    local filename=$2
    local obj_name=$3
    local content_type=$4
    local size=$5
    local opt_silent=$6

    local etag=`bf_md5 $filename`

    bf_curl $container/$obj_name --request PUT \
            --header "Content-Type: $content_type" \
            --header "ETag: $etag" --upload-file $filename $opt_silent
}


function cf_put_large_object() {
    local container=$1
    local filename=$2
    local obj_name=$3
    local content_type=$4
    local size=$5
    local opt_silent=$6

    local left=$size
    local segment_num=1
    local skip=0

    local seg_container=${obj_name}_segments
    local seg_prefix="$seg_container/$obj_name/`date +%s`/$size/"

    bf_mkdir ${seg_container}

    local total_segments=`bf_compute_num_blocks $size $CF_SEGMENT_SIZE`

    while [[ $left -gt 0 ]]; do
        if [[ $left -ge $CF_SEGMENT_SIZE ]]; then
            local length=$CF_SEGMENT_SIZE
        else
            local length=$left
        fi

        local nblocks=`bf_compute_num_blocks $length $DD_BLOCK_SIZE`

        bf_log "Uploading segment $segment_num/$total_segments"

        # FIXME: unify this with bf_curl
        bf_init
        local seg_name="$seg_prefix$(printf '%08d' $segment_num)"
        seg_name=`bf_urlencode $seg_name`
        local code=$(
            dd if=$filename bs=$DD_BLOCK_SIZE count=$nblocks skip=$skip \
                2> /dev/null | \
            curl --fail --write-out '%{http_code}' $opt_silent \
                 --header "X-Auth-Token: $CF_AUTH_TOKEN" \
                 --upload-file - --request PUT \
                 --header "Transfer-Encoding: chunked" \
                 --header "Content-Type: $content_type" \
                 $CF_STORAGE_URL/$seg_name)

        bf_check_code $code

        bf_log ""

        let left-=$length
        let skip+=$nblocks
        let segment_num++
    done

    bf_log "Uploading manifest for ${filename}"
    bf_curl ${container}/${obj_name} --data-binary '' --output /dev/null \
            --request PUT --header "Content-Type: ${content_type}" \
            --header "X-Object-Manifest: ${seg_prefix}" \
            $opt_silent
}


function cf_put() {
    local container=$1
    shift
    local filenames=$@

    local ret=0
    local opt_silent=

    if [[ $OPT_QUIET -eq 1 ]]; then
        opt_silent=--silent
    fi

    for filename in $filenames; do
        if [[ ! -e $filename ]]; then
            bf_error "File not found: $filename"
            ret=1
            continue
        fi

        local obj_name=`basename $filename`

        if [[ -n $OPT_CONTENT_TYPE ]]; then
            local content_type=$OPT_CONTENT_TYPE
        else
            local content_type=`bf_autodetect_filetype $filename`
        fi

        local size=`bf_size $filename`

        if [[ $size -gt $CF_SEGMENT_SIZE ]]; then
            cf_put_large_object $container $filename $obj_name \
                                "$content_type" $size $opt_silent
        else
            cf_put_small_object $container $filename $obj_name \
                                "$content_type" $size $opt_silent
        fi
    done

    return $ret
}


function cf_rm() {
    local container=$1
    shift
    local obj_names=$@

    for obj_name in $obj_names; do
        bf_curl $container/$obj_name --silent --request DELETE
    done
}


function bf_clear_container() {
    local container=$1

    # TODO: handle pagination
    local obj_names=`bf_ls $container`

    # NOTE: tr -d is needed for Mac OS X, since wc -w has leading spaces
    # in output
    local total_objects=`echo $obj_names | wc -w | tr -d ' '`
    local idx=1

    for obj_name in $obj_names; do
        bf_log "Deleting $idx/$total_objects: $obj_name"
        let idx++
        bf_rm $container $obj_name
    done
}


function bf_rmdir() {
    local containers=$@

    if [[ -z $containers ]]; then
        bf_usage 'rmdir <containers>'
    fi

    for container in $containers; do
        if [[ $OPT_FORCE -eq 1 ]]; then
            bf_clear_container $container
        fi

        bf_curl $container --silent --request DELETE
    done
}


function bf_stat() {
    local container=$1
    shift
    local obj_names=$@

    for obj_name in $obj_names; do
        local tmp_file=`bf_mktemp`

        # NOTE: if we used --request HEAD instead of --head, curl would expect
        # Content-Length bytes to be sent as entity body which would cause a
        # timeout since HEAD requests don't result in a body
        bf_curl $container/$obj_name --silent --output /dev/null --head \
                --dump-header $tmp_file

        cat $tmp_file
        rm $tmp_file
    done
}


function bf_init() {
    if [[ $CF_INITIALIZED -eq 1 ]]; then
        return
    fi

    bf_retrieve_credentials
    bf_auth

    if [[ $BF_SMART_COMPLETION -eq 1 && ! -d $BF_COMPLETION_DIR ]]; then
        mkdir $BF_COMPLETION_DIR
    fi

    CF_INITIALIZED=1
}


#############################################################################
#                                                                           #
#                                    Main                                   #
#                                                                           #
#############################################################################


while getopts 'fho:qst:v' opt; do
    case $opt in
        f)
            OPT_FORCE=1;;
        h)
            bf_help;;
        o)
            OPT_OUTPUT=$OPTARG;;
        q)
            OPT_QUIET=1;;
        s)
            OPT_SERVICENET=1;;
        t)
            OPT_CONTENT_TYPE=$OPTARG;;
        v)
            bf_version;;
        *)
            bf_general_usage;;
    esac
done

shift $(($OPTIND - 1))

cmd=$1

shift

case $cmd in
    cp)
        cmd_cp $@;;
    ls)
        cmd_ls $@;;
    get)
        cmd_get $@;;
    mkdir)
        cmd_mkdir $@;;
    mv)
        cmd_mv $@;;
    put)
        cmd_put $@;;
    rm)
        cmd_rm $@;;
    rmdir)
        bf_rmdir $@;;
    stat)
        bf_stat $@;;
    *)
        bf_general_usage;;
esac
